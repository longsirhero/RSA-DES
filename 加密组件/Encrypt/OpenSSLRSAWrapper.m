// OpenSSLRSAWrapper.m
// Version 3.0
//
// Copyright (c) 2012 scott ban ( http://github.com/reference )
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

#import "OpenSSLRSAWrapper.h"
#import "NSString+Base64.h"
#import "NSData+Base64.h"
#import <openssl/pem.h>


#define DocumentsDir [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject]
#define OpenSSLRSAKeyDir [DocumentsDir stringByAppendingPathComponent:@".openssl_rsa"]
#define OpenSSLRSAPublicKeyFile [OpenSSLRSAKeyDir stringByAppendingPathComponent:@"publicKey5.pem"]
#define OpenSSLRSAPrivateKeyFile [OpenSSLRSAKeyDir stringByAppendingPathComponent:@"privateKey.pem"]

@implementation OpenSSLRSAWrapper
@synthesize publicKeyBase64,privateKeyBase64;

#pragma mark - getter

// Helper function for ASN.1 encoding

size_t encodeLength(unsigned char * buf, size_t length) {
    
    // encode length in ASN.1 DER format
    if (length < 128) {
        buf[0] = length;
        return 1;
    }
    
    size_t i = (length / 256) + 1;
    buf[0] = i + 0x80;
    for (size_t j = 0 ; j < i; ++j) {
        buf[i - j] = length & 0xFF;
        length = length >> 8;
    }
    
    return i + 1;
}

- (NSData*)publicKeyBitsWithString:(NSString*)str{
    
    static const unsigned char _encodedRSAEncryptionOID[15] = {
        
        /* Sequence of length 0xd made up of OID followed by NULL */
        0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86,
        0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00
        
    };
    
    NSData *publicKeyBits_ = [str base64DecodedData];
    
    // OK - that gives us the "BITSTRING component of a full DER
    // encoded RSA public key - we now need to build the rest
    
    unsigned char builder[15];
    NSMutableData * encKey = [NSMutableData dataWithCapacity:0];
    NSUInteger bitstringEncLength;
    
    // When we get to the bitstring - how will we encode it?
    if ([publicKeyBits_ length] + 1 < 128)
        bitstringEncLength = 1;
    else
        bitstringEncLength = (([publicKeyBits_ length] +1) / 256) + 2;
    
    // Overall we have a sequence of a certain length
    builder[0] = 0x30;    // ASN.1 encoding representing a SEQUENCE
    // Build up overall size made up of -
    // size of OID + size of bitstring encoding + size of actual key
    size_t i = sizeof(_encodedRSAEncryptionOID) + 2 + bitstringEncLength +
    [publicKeyBits_ length];
    size_t j = encodeLength(&builder[1], i);
    [encKey appendBytes:builder length:j +1];
    
    // First part of the sequence is the OID
    [encKey appendBytes:_encodedRSAEncryptionOID
                 length:sizeof(_encodedRSAEncryptionOID)];
    
    // Now add the bitstring
    builder[0] = 0x03;
    j = encodeLength(&builder[1], [publicKeyBits_ length] + 1);
    builder[j+1] = 0x00;
    [encKey appendBytes:builder length:j + 2];
    
    // Now the actual key
    [encKey appendData:publicKeyBits_];
    
    return encKey;
}

- (NSString*)publicKeyBase64{
    NSFileManager *fm = [NSFileManager defaultManager];
    if ([fm fileExistsAtPath:OpenSSLRSAPublicKeyFile]) {
        NSString *str = [NSString stringWithContentsOfFile:OpenSSLRSAPublicKeyFile encoding:NSUTF8StringEncoding error:nil];
        
        /*
         This return value based on the key that generated by openssl.
         
         -----BEGIN RSA PUBLIC KEY-----
         MIGHAoGBAOp5TLclpWCaNDzHYPfB26SLmS8vlSXH4PyKopz5OS5Vx994FBQQLwv9
         2pIJQsBk09egrL0gbASK1VCwDt0MmaiyrNFl/xaEzB/VOvjoojBUzMMIca9fKmx5
         GAzSbSP7we64dhvrziuuNVTuM/e2XSa2skKFHMI0bCq4+pNYhvRhAgED
         -----END RSA PUBLIC KEY-----
         */
//        NSLog(@"OpenSSLRSAPublicKeyFile = %@", str);
        NSData *data = [self publicKeyBitsWithString:[[str componentsSeparatedByString:@"-----"] objectAtIndex:2]];
        
        return [data base64EncodedString];
    }
    return nil;
}

- (NSString*)privateKeyBase64{
    NSFileManager *fm = [NSFileManager defaultManager];
    if ([fm fileExistsAtPath:OpenSSLRSAPrivateKeyFile]) {
        NSString *str = [NSString stringWithContentsOfFile:OpenSSLRSAPrivateKeyFile encoding:NSUTF8StringEncoding error:nil];
        
        /*
         This return value based on the key that generated by openssl.
         
         -----BEGIN RSA PRIVATE KEY-----
         MIICXAIBAAKBgQDqeUy3JaVgmjQ8x2D3wduki5kvL5Ulx+D8iqKc+TkuVcffeBQU
         EC8L/dqSCULAZNPXoKy9IGwEitVQsA7dDJmosqzRZf8WhMwf1Tr46KIwVMzDCHGv
         XypseRgM0m0j+8HuuHYb684rrjVU7jP3tl0mtrJChRzCNGwquPqTWIb0YQIBAwKB
         gQCcUN3Pbm5AZs192kClK+fDB7t0ymNuhUCoXGxopiYe49qU+rgNYB9dU+cMBiyA
         QzflFch+FZ1YXI41yrSTXbvEhcYQy7jdFVJiqNH4Cu767ETzLMFDiDXIv5/h72iN
         hfeRWTW/KbyZbEtq/HeTjIg7rP3h8Fveh/Fj3EY4bmlqgwJBAPbQFmacHXeO4xcP
         aLhFVX/lDrmL7o1TIFNAp8xH/Kqf+L4+uSzoqyvPzO3w2ATdge+VnLhrxzzU48eg
         Y3wHpY8CQQDzM6HNza1tQajA8Jwf9mJygEeLw9uFhp8GZ5IfCFMILpv0ZsQASppf
         9GeFj8Jes0tDn9LkJy0rrTEm8Ns24S8PAkEApIq5mb1o+l9CD1+bJYOOVUNfJl1J
         s4zAN4Bv3YVTHGql1CnQyJscx9/d8/XlWJOr9Q5oevKE0ziX2mrs/VpuXwJBAKIi
         a96JHkjWcICgaBVO7ExVhQfX565Zv1maYWoFjLAfEqLvLVWHEZVNmlkKgZR3h4Jq
         jJgaHh0eIMSgkiSWH18CQGsFhFEdBonmeIm1kY1YWjpM4WS0kUlXOC3sCYg8eXFe
         YEEr9pnY+hhDFegEItQd1hAvrqQhpxhX7HhNNxUoPp4=
         -----END RSA PRIVATE KEY-----
         */
        return [[str componentsSeparatedByString:@"-----"] objectAtIndex:2];
    }
    return nil;
}

- (id)init{
    if (self = [super init]) {
        //load RSA if it is exsit
        NSFileManager *fm = [NSFileManager defaultManager];
        if (![fm fileExistsAtPath:OpenSSLRSAKeyDir]) {
            [fm createDirectoryAtPath:OpenSSLRSAKeyDir withIntermediateDirectories:YES attributes:nil error:nil];
        }
    }return self;
}

+ (id)shareInstance{
    static OpenSSLRSAWrapper *_opensslWrapper = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        _opensslWrapper = [[self alloc] init];
    });
    return _opensslWrapper;
}

+ (BOOL)canImportRSAKeys{
    NSFileManager *fm = [NSFileManager defaultManager];
    return [fm fileExistsAtPath:OpenSSLRSAPublicKeyFile] && [fm fileExistsAtPath:OpenSSLRSAPrivateKeyFile];
}

- (void)writeKeyToFile:(NSString *)publicKey :(NSString*)privateKey
{
    if (publicKey) {
        NSError* error;
        if ([publicKey writeToFile:OpenSSLRSAPublicKeyFile atomically:YES encoding:NSASCIIStringEncoding error:&error]) {
//            NSData* data = [NSData dataWithContentsOfFile:OpenSSLRSAPublicKeyFile];
//            NSLog(@"publicKey = %@", [[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding]);
        }
        else{
            
        }
    }
    if (privateKey) {
        NSError* error;
        if ([privateKey writeToFile:OpenSSLRSAPrivateKeyFile atomically:YES encoding:NSASCIIStringEncoding error:&error]) {
        }
    }
}

- (BOOL)generateRSAKeyPairWithKeySize:(NSInteger)keySize {
    if (NULL != _rsa) {
        RSA_free(_rsa);
        _rsa = NULL;
    }
    _rsa = RSA_generate_key((int)keySize,RSA_F4,NULL,NULL);
    assert(_rsa != NULL);
    
    if (_rsa) {
        return YES;
    }return NO;
}

- (BOOL)exportRSAKeys{
    assert(_rsa != NULL);
    
    if (_rsa != NULL) {
//        NSString *privatePath = [[NSBundle mainBundle] pathForResource:@"private2" ofType:@"pem"];
//        NSString *publicPath = [[NSBundle mainBundle]pathForResource:@"public2" ofType:@"pem"];
        FILE *filepub,*filepri;
        filepri = fopen([OpenSSLRSAPrivateKeyFile cStringUsingEncoding:NSASCIIStringEncoding],"w");
        filepub = fopen([OpenSSLRSAPublicKeyFile cStringUsingEncoding:NSASCIIStringEncoding],"w");
        
        if (NULL != filepub && NULL != filepri) {
            int retpri = -1;
            int retpub = -1;
            
            RSA *_pribrsa = RSAPrivateKey_dup(_rsa);
            assert(_pribrsa != NULL);
            retpri = PEM_write_RSAPrivateKey(filepri, _pribrsa, NULL, NULL, 512, NULL, NULL);
            RSA_free(_pribrsa);
            
            RSA *_pubrsa = RSAPublicKey_dup(_rsa);
            assert(_pubrsa != NULL);
            retpub = PEM_write_RSAPublicKey(filepub, _pubrsa);
            RSA_free(_pubrsa);
            
            fclose(filepub);
            fclose(filepri);
            
            return (retpri+retpub>1)?YES:NO;
        }
    }return NO;
}

//根据密钥类型从本地取出钥匙对
- (BOOL)importRSAKeyWithType:(KeyType)type{
    FILE *file;
//     NSString* path = [[NSBundle mainBundle] pathForResource:@"public2" ofType:@"pem"];
    if (type == KeyTypePublic) {
       
        file = fopen([OpenSSLRSAPublicKeyFile cStringUsingEncoding:NSASCIIStringEncoding],"rb");
    }else{
        file = fopen([OpenSSLRSAPrivateKeyFile cStringUsingEncoding:NSASCIIStringEncoding],"rb");
    }
    
    if (NULL != file) {
        
        if (type == KeyTypePublic) {
            
            BIO *key1=NULL;
            key1=BIO_new(BIO_s_file());
           const char* tempPath = [OpenSSLRSAPublicKeyFile cStringUsingEncoding:NSUTF8StringEncoding];
            if(BIO_read_filename(key1,tempPath) <= 0 )
            {
                printf("error\n");
            }
            _rsa = PEM_read_bio_RSA_PUBKEY(key1, NULL,NULL,NULL);
            assert(_rsa != NULL);
//            PEM_write_RSAPublicKey(stdout, _rsa);
            BIO_free_all(key1);
            key1 = NULL;
           
        }else{
            _rsa = PEM_read_RSAPrivateKey(file, NULL, NULL, NULL);
            assert(_rsa != NULL);
            PEM_write_RSAPrivateKey(stdout, _rsa, NULL, NULL, 0, NULL, NULL);
        }
        
        fclose(file);
        return (_rsa != NULL)?YES:NO;
    } return NO;
}

//使用公钥或私钥RSA加密数据
- (NSData*)encryptRSAKeyWithType:(KeyType)keyType paddingType:(RSA_PADDING_TYPE)padding data:(NSData*)d{
    if (d && [d length]) {
        NSUInteger flen = [d length];
        unsigned char from[flen];
        bzero(from, sizeof(from));
        memcpy(from, [d bytes], [d length]);

        unsigned char to[128];
        bzero(to, sizeof(to));
        
        [self encryptRSAKeyWithType:keyType :from :(int)flen :to :padding];
        
        return [NSData dataWithBytes:to length:sizeof(to)];
    }
    return nil;
}

- (NSData*)encryptRSAKeyWithType:(KeyType)keyType paddingType:(RSA_PADDING_TYPE)padding plainText:(NSString*)text usingEncoding:(NSStringEncoding)encode{
    if (text && [text length]) {
        return [self encryptRSAKeyWithType:keyType paddingType:padding data:[text dataUsingEncoding:encode]];
    }return nil;
}

- (NSString*)decryptRSAKeyWithType:(KeyType)keyType paddingType:(RSA_PADDING_TYPE)padding plainTextData:(NSData*)data usingEncoding:(NSStringEncoding)encode{
    if (data && [data length]) {
        NSData *decryptData = [self decryptRSAKeyWithType:keyType paddingType:padding encryptedData:data];
        return [[NSString alloc] initWithData:decryptData encoding:encode];
    }return nil;
}

- (NSData*)decryptRSAKeyWithType:(KeyType)keyType paddingType:(RSA_PADDING_TYPE)padding encryptedData:(NSData*)data{
    if (data && [data length]) {
        
        NSUInteger flen = [data length];
        unsigned char from[flen];
        bzero(from, sizeof(from));
        memcpy(from, [data bytes], [data length]);
        
        unsigned char to[128];
        bzero(to, sizeof(to));
        
        [self decryptRSAKeyWithType:keyType :from :(int)flen :to :padding];
        
        return [NSData dataWithBytes:to length:sizeof(to)];
    }
    return nil;
}

- (int)getBlockSizeWithRSA_PADDING_TYPE:(RSA_PADDING_TYPE)padding_type{
    
    int len = RSA_size(_rsa);
    
    if (padding_type == RSA_PADDING_TYPE_PKCS1 || padding_type == RSA_PADDING_TYPE_SSLV23) {
        len -= 11;
    }
    
    return len;
}

- (NSString*)getPemStr:(NSString*)key :(KeyType)type
{
    NSMutableString* resStr = nil;
    if (type == KeyTypePrivate) {
        resStr = [NSMutableString stringWithString:@"-----BEGIN RSA PRIVATE KEY-----\n"];
        
    }
    if (type == KeyTypePublic) {
        resStr = [NSMutableString stringWithString:@"-----BEGIN PUBLIC KEY-----\n"];
    }
    
    NSUInteger num = key.length/64;
    for(int i = 0; i <=num;i++)
    {
        if (i <num) {
            NSString* str = [NSString stringWithFormat:@"%@\n", [key substringWithRange:NSMakeRange(i*64, 64)]];
            [resStr appendString:str];
        }
        if (i == num && key.length -i*64>0) {
            NSString* str = [NSString stringWithFormat:@"%@\n", [key substringWithRange:NSMakeRange(i*64, key.length -i*64)]];
            [resStr appendString:str];
        }
    }
    if (type == KeyTypePrivate) {
        [resStr appendString:@"-----END RSA PRIVATE KEY-----"];
    }
    if (type == KeyTypePublic) {
        [resStr appendString:@"-----END PUBLIC KEY-----"];
    }
    
    return resStr;
}

#pragma mark - Base

- (int)encryptRSAKeyWithType:(KeyType)keyType :(const unsigned char *)from :(int)flen :(unsigned char *)to :(RSA_PADDING_TYPE)padding{
    if (from != NULL && to != NULL) {
//        int status = RSA_check_key(_rsa);
        int status = -1;
//        if (!status) {
//            NSLog(@"status code %i",status);
//            return -1;
//        }
        
        switch (keyType) {
            case KeyTypePrivate:{
                //start encrypt
                status =  RSA_private_encrypt(flen, from,to, _rsa,  padding);
            }
                break;
                
            default:{
                //start encrypt
                status =  RSA_public_encrypt(flen,from,to, _rsa,  padding);
            }
                break;
        }
        
        return status;
    }return -1;
}

- (int)decryptRSAKeyWithType:(KeyType)keyType :(const unsigned char *)from :(int)flen :(unsigned char *)to :(RSA_PADDING_TYPE)padding{
    if (from != NULL && to != NULL) {
//        int status = RSA_check_key(_rsa);
        int status = -1;
//        if (!status) {
//            NSLog(@"status code %i",status);
//            return -1;
//        }
        
        switch (keyType) {
            case KeyTypePrivate:{
                //start encrypt
                status =  RSA_private_decrypt(flen, from,to, _rsa,  padding);
            }
                break;
                
            default:{
                //start encrypt
                status =  RSA_public_decrypt(flen,from,to, _rsa,  padding);
            }
                break;
        }
        
        return status;
    }return -1;
}


//3DES三重数据加密解密
+ (NSString *)TripleDES:(NSString *)plainText encryptOrDecrypt:(CCOperation)encryptOrDecrypt encryptOrDecryptKey:(NSString *)encryptOrDecryptKey
{
    
    const void *vplainText;
    size_t plainTextBufferSize;
    
    if (encryptOrDecrypt == kCCDecrypt)//解密
    {
        //解码 base64
        NSData *EncryptData = [plainText base64DecodedData];
//        NSData* EncryptData = [plainText dataUsingEncoding:NSUTF8StringEncoding];
        plainTextBufferSize = [EncryptData length];
        vplainText = [EncryptData bytes];
    }
    else //加密
    {
        NSData* data = [plainText dataUsingEncoding:NSUTF8StringEncoding];
        plainTextBufferSize = [data length];
        vplainText = (const void *)[data bytes];
    }
    
    /*
     DES加密 ：用CCCrypt函数加密一下，然后用base64编码下，传过去
     DES解密 ：把收到的数据根据base64，decode一下，然后再用CCCrypt函数解密，得到原本的数据
     */
    CCCryptorStatus ccStatus;
    uint8_t *bufferPtr = NULL;
    size_t bufferPtrSize = 0;
    size_t movedBytes = 0;
    
    bufferPtrSize = (plainTextBufferSize + kCCBlockSize3DES) & ~(kCCBlockSize3DES - 1);
    bufferPtr = malloc( bufferPtrSize * sizeof(uint8_t));
    memset((void *)bufferPtr, 0x0, bufferPtrSize);//将bufferPtr中前bufferPtrSize个字节用0替换并返回bufferPtr
    // memset((void *) iv, 0x0, (size_t) sizeof(iv));
    
    const void *vkey = (const void *)[encryptOrDecryptKey UTF8String];
    // NSString *initVec = @"init Vec";
    //const void *vinitVec = (const void *) [initVec UTF8String];
//      Byte iv[] = {0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF};
    
    //CCCrypt函数 加密/解密
    ccStatus = CCCrypt(encryptOrDecrypt,//加密/解密
                       kCCAlgorithm3DES,//根据哪个标准进行加密（des，3des，aes。。。。）
                       kCCOptionPKCS7Padding | kCCOptionECBMode,
                       vkey,//密钥    加密和解密的密钥必须一致 
                       kCCKeySize3DES,//DES 密钥的大小（kCCKeySize3DES=24）
                       nil,//可选的初始矢量
                       vplainText,//数据的存储单元
                       plainTextBufferSize,//数据的大小
                       (void *)bufferPtr,//用于返回数据
                       bufferPtrSize,
                       &movedBytes);
//    if (ccStatus == kCCSuccess) NSLog(@"SUCCESS");// modify by Y_QQ
    /*else if (ccStatus == kCC ParamError) return @"PARAM ERROR";
     else if (ccStatus == kCCBufferTooSmall) return @"BUFFER TOO SMALL";
     else if (ccStatus == kCCMemoryFailure) return @"MEMORY FAILURE";
     else if (ccStatus == kCCAlignmentError) return @"ALIGNMENT";
     else if (ccStatus == kCCDecodeError) return @"DECODE ERROR";
     else if (ccStatus == kCCUnimplemented) return @"UNIMPLEMENTED"; */
    
    NSString *result;
    
    if (encryptOrDecrypt == kCCDecrypt)//解码
    {
        //得到解密出来的data数据，转成utf-8的字符串
        result = [[NSString alloc] initWithData:[NSData dataWithBytes:(const void *)bufferPtr
                                                                length:(NSUInteger)movedBytes]
                                        encoding:NSUTF8StringEncoding]
                  ;
    }
    else //encryptOperation==0  （加密过程中，把加好密的数据转成base64的）
    {
        //编码 base64
        NSData *myData = [NSData dataWithBytes:(const void *)bufferPtr length:(NSUInteger)movedBytes];
        result = [myData base64EncodedString];
//        result = [[NSString alloc] initWithData:myData encoding:NSASCIIStringEncoding];
    }
    free(bufferPtr);
    return result;
}

int rsa_verify_with_public_key_pem(char *message, int message_length
                                   , unsigned char *signature, unsigned int signature_length
                                   , char *public_key_file_path)
{
    unsigned char sha1[20];
    SHA1((unsigned char *)message, message_length, sha1);
    BIO *bio_public = NULL;
    RSA *rsa_public = NULL;
    bio_public = BIO_new(BIO_s_file());
    BIO_read_filename(bio_public, public_key_file_path);
    rsa_public = PEM_read_bio_RSA_PUBKEY(bio_public, NULL, NULL, NULL);
    
    int rsa_verify_valid = RSA_verify(NID_sha1
                                      , sha1, 20
                                      , signature, signature_length
                                      , rsa_public);
    BIO_free_all(bio_public);
    if (1 == rsa_verify_valid)
    {
        return 1;
    }
    return 0;
}

+(NSString *)DES:(NSString *)plainText encryptOrDecrypt:(CCOperation)encryptOrDecrypt encryptOrDecryptKey:(NSString *)encryptOrDecryptKey
{
    const Byte iv[] = {1,2,3,4,5,6,7,8};
    const void *vplainText;
    size_t plainTextBufferSize;
    unsigned char buffer[1024];
    memset(buffer, 0, sizeof(char));
    size_t movedBytes = 0;
    
    if (encryptOrDecrypt == kCCDecrypt)//解密
    {
        NSData *EncryptData = [self getByteFromStr:plainText];
        //        NSData* EncryptData = [plainText dataUsingEncoding:NSUTF8StringEncoding];
        plainTextBufferSize = [EncryptData length];
        vplainText = [EncryptData bytes];
    }
    else //加密
    {
        NSData* data = [plainText dataUsingEncoding:NSUTF8StringEncoding];
        plainTextBufferSize = [data length];
        vplainText = (const void *)[data bytes];
    }
    
    CCCryptorStatus ccStatus;
    const void *vkey = (const void *)[encryptOrDecryptKey UTF8String];
    ccStatus = CCCrypt(encryptOrDecrypt,
                       kCCAlgorithmDES,
                       kCCOptionPKCS7Padding | kCCOptionECBMode,
                       vkey,
                       kCCKeySizeDES,
                       iv,
                       vplainText,
                       plainTextBufferSize,
                       buffer,
                       1024,
                       &movedBytes);
    //if (ccStatus == kCCSuccess) NSLog(@"SUCCESS");
    /*else if (ccStatus == kCC ParamError) return @"PARAM ERROR";
     else if (ccStatus == kCCBufferTooSmall) return @"BUFFER TOO SMALL";
     else if (ccStatus == kCCMemoryFailure) return @"MEMORY FAILURE";
     else if (ccStatus == kCCAlignmentError) return @"ALIGNMENT";
     else if (ccStatus == kCCDecodeError) return @"DECODE ERROR";
     else if (ccStatus == kCCUnimplemented) return @"UNIMPLEMENTED"; */
     NSString *result = nil;
    if (ccStatus == kCCSuccess) {
        if (encryptOrDecrypt == kCCDecrypt)
        {
            result = [[NSString alloc] initWithData:[NSData dataWithBytes:(const void *)buffer
                                                                   length:(NSUInteger)movedBytes]
                                           encoding:NSUTF8StringEncoding]
            ;
        }
        else
        {
            NSData *myData = [NSData dataWithBytes:(const void *)buffer length:(NSUInteger)movedBytes];
//            result = [myData base64EncodedString];
//            NSLog(@"mydata = %@",myData);
            result = [self parseByte2HexString:(Byte*)[myData bytes] length:(int)myData.length];
        }
    }
    return result;
    
}

+(NSData*)getByteFromStr:(NSString*)str
{
    NSData* data = nil;
    NSUInteger length = str.length;
    if (length%2 != 0) {
        return nil;
    }
    NSUInteger count = length/2;
    Byte bytes[count];
    bzero(bytes, count);
    
    for (int i = 0; i <count; i++) {
        unsigned int temp;
        NSString* subStr = [str substringWithRange:NSMakeRange(i*2, 2)];
        NSScanner* scaner = [[NSScanner alloc]initWithString:subStr];
        if ([scaner scanHexInt:&temp]) {
            bytes[i] = temp;
        }
    }
    
    data = [NSData dataWithBytes:bytes length:count];
    return data;
}

+(NSString *) parseByte2HexString:(Byte *) bytes length:(int)length
{
       NSMutableString *hexStr = [[NSMutableString alloc]init];
    
       if(bytes)
        {
            for (int i = 0; i <length; i++) {
                NSString *hexByte = [NSString stringWithFormat:@"%x",bytes[i] & 0xff];///16进制数
                if([hexByte length]==1)
                    [hexStr appendFormat:@"0%@", hexByte];
                
                else
                    [hexStr appendFormat:@"%@", hexByte];
            }
      }
    
//      NSLog(@"bytes 的16进制数为:%@",hexStr);
    
      return hexStr;
    
}

void rsaVerifyString(NSString *stringToVerify, NSString *signature, NSString *publicKeyFilePath, BOOL *verifySuccess)
{
    const char *message = [stringToVerify cStringUsingEncoding:NSUTF8StringEncoding];
    NSUInteger messageLength = [stringToVerify lengthOfBytesUsingEncoding:NSUTF8StringEncoding];
    NSData *signatureData = [signature base64DecodedData];
    unsigned char *sig = (unsigned char *)[signatureData bytes];
    NSUInteger sig_len = [signatureData length];
    char *filePath = (char *)[publicKeyFilePath cStringUsingEncoding:NSUTF8StringEncoding];
    int verify_ok = rsa_verify_with_public_key_pem((char *)message, (int)messageLength
                                                   , sig, (int)sig_len
                                                   , filePath);
    if (1 == verify_ok)
    {
        *verifySuccess = YES;
    }
    else
    {
        *verifySuccess = NO;
    }
}

- (BOOL)rsaVerifyWithString:(NSString*)stringToVerify signature:(NSString*)signature publicaKeyPath:(NSString*)path
{
    BOOL ret ;
    rsaVerifyString(stringToVerify, signature, path, &ret);
    return ret;
}

- (NSString*)getPublickeyPath
{
    return OpenSSLRSAPublicKeyFile;
}
//const Byte iv[] = {1,2,3,4,5,6,7,8};
//+(NSString *) encryptUseDES:(NSString *)plainText key:(NSString *)key
//{
//         NSString *ciphertext = nil;
//         NSData *textData = [plainText dataUsingEncoding:NSUTF8StringEncoding];
//         NSUInteger dataLength = [textData length];
//         unsigned char buffer[1024];
//         memset(buffer, 0, sizeof(char));
//         size_t numBytesEncrypted = 0;
//         CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt,
//                                               kCCAlgorithmDES,
//                                               kCCOptionPKCS7Padding,
//                                               [key UTF8String],
//                                               kCCKeySizeDES,
//                                               iv,
//                                               [textData bytes],
//                                               dataLength,
//                                               buffer, 1024,
//                                               &numBytesEncrypted);
//         if (cryptStatus == kCCSuccess) {
//                 NSData *data = [NSData dataWithBytes:buffer length:(NSUInteger)numBytesEncrypted];
//                 ciphertext = [data base64EncodedString];
//             }
//         return ciphertext;
//}
//
//+(NSString *)decryptUseDES:(NSString *)cipherText key:(NSString *)key
//{
//         NSString *plaintext = nil;
//         NSData *cipherdata = [cipherText base64DecodedData];
//         unsigned char buffer[1024];
//         memset(buffer, 0, sizeof(char));
//         size_t numBytesDecrypted = 0;
//         CCCryptorStatus cryptStatus = CCCrypt(kCCDecrypt,
//                                               kCCAlgorithmDES,
//                                               kCCOptionPKCS7Padding,
//                                               [key UTF8String],
//                                               kCCKeySizeDES,
//                                               iv,
//                                               [cipherdata bytes],
//                                               [cipherdata length],
//                                               buffer,
//                                               1024,
//                                               &numBytesDecrypted);
//         if(cryptStatus == kCCSuccess) {
//                 NSData *plaindata = [NSData dataWithBytes:buffer length:(NSUInteger)numBytesDecrypted];
//                 plaintext = [[NSString alloc]initWithData:plaindata encoding:NSUTF8StringEncoding];
//             }
//         return plaintext;
//}
@end
